<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>후후의 테트리스</title>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #2c3e50;
            font-family: 'Malgun Gothic', sans-serif;
            color: #333;
        }

        #tetris-game {
            display: flex;
            gap: 20px;
            border: 5px solid #34495e;
            padding: 20px;
            background-color: #ecf0f1;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            border-radius: 15px;
        }

        canvas {
            display: block;
            background-color: #1a1a1a;
            border: 2px solid #2c3e50;
        }

        #info {
            text-align: center;
            min-width: 160px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        h2 {
            margin: 0;
            background: #4CAF50;
            color: white;
            padding: 10px;
            border-radius: 8px;
            font-size: 1.2em;
        }

        #score-box {
            font-size: 1.2em;
            margin: 10px 0;
            font-weight: bold;
        }

        #score {
            color: #e67e22;
            font-size: 1.4em;
        }

        .controls {
            text-align: left;
            font-size: 0.85em;
            background: #dfe6e9;
            padding: 10px;
            border-radius: 5px;
            line-height: 1.6;
        }

        button {
            padding: 15px;
            cursor: pointer;
            font-size: 1.1em;
            font-weight: bold;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            transition: 0.2s;
        }

        button:hover {
            background-color: #45a049;
        }

        #game-over {
            color: #d63031;
            font-weight: bold;
            display: none;
        }
    </style>
</head>
<body>

<div id="tetris-game">
    <canvas id="board" width="200" height="400"></canvas>
    
    <div id="info">
        <div>
            <h2>후후의 테트리스</h2>
            <div id="score-box">점수: <span id="score">0</span></div>
            <p>NEXT</p>
            <canvas id="next" width="80" height="80"></canvas>
        </div>

        <div class="controls">
            <strong>[조작키]</strong><br>
            ← → : 이동<br>
            ↑ : 회전<br>
            ↓ : 빨리 내리기<br>
            Space : 즉시 낙하
        </div>

        <button onclick="startGame()">게임 시작</button>
        <div id="game-over">GAME OVER</div>
    </div>
</div>

<script>
    const canvas = document.getElementById('board');
    const ctx = canvas.getContext('2d');
    const nextCanvas = document.getElementById('next');
    const nctx = nextCanvas.getContext('2d');
    const scoreElement = document.getElementById('score');

    const ROW = 20;
    const COL = 10;
    const SQ = 20;
    const VACANT = "#1a1a1a"; // 빈 공간 색상

    const PIECES = [
        [ [[1,1,1,1]], "#00cec9" ], // I
        [ [[0,1,0],[1,1,1]], "#a29bfe" ], // T
        [ [[1,1],[1,1]], "#fdcb6e" ], // O
        [ [[1,1,0],[0,1,1]], "#55efc4" ], // S
        [ [[0,1,1],[1,1,0]], "#ff7675" ], // Z
        [ [[1,0,0],[1,1,1]], "#fab1a0" ], // L
        [ [[0,0,1],[1,1,1]], "#74b9ff" ]  // J
    ];

    let board = [];
    let score = 0;
    let gameRunning = false;
    let dropStart = Date.now();
    let p; // 현재 블록
    let nextP; // 다음 블록

    // 보드 초기화
    function initBoard() {
        for(let r = 0; r < ROW; r++){
            board[r] = [];
            for(let c = 0; c < COL; c++){
                board[r][c] = VACANT;
            }
        }
    }

    function drawSquare(x, y, color, context = ctx) {
        context.fillStyle = color;
        context.fillRect(x*SQ, y*SQ, SQ, SQ);
        context.strokeStyle = "#2c3e50";
        context.strokeRect(x*SQ, y*SQ, SQ, SQ);
    }

    function drawBoard() {
        for(let r = 0; r < ROW; r++){
            for(let c = 0; c < COL; c++){
                drawSquare(c, r, board[r][c]);
            }
        }
    }

    class Piece {
        constructor(tetromino, color) {
            this.tetromino = tetromino;
            this.color = color;
            this.activeTetromino = this.tetromino[0];
            this.x = 3;
            this.y = -2;
        }

        fill(color, context = ctx) {
            for(let r = 0; r < this.activeTetromino.length; r++){
                for(let c = 0; c < this.activeTetromino.length; c++){
                    if(this.activeTetromino[r][c]){
                        drawSquare(this.x + c, this.y + r, color, context);
                    }
                }
            }
        }

        draw() { this.fill(this.color); }
        unDraw() { this.fill(VACANT); }

        moveDown() {
            if(!this.collision(0, 1, this.activeTetromino)){
                this.unDraw();
                this.y++;
                this.draw();
            } else {
                this.lock();
                p = nextP;
                nextP = randomPiece();
                drawNext();
            }
        }

        moveRight() { if(!this.collision(1, 0, this.activeTetromino)){ this.unDraw(); this.x++; this.draw(); } }
        moveLeft() { if(!this.collision(-1, 0, this.activeTetromino)){ this.unDraw(); this.x--; this.draw(); } }

        rotate() {
            let nextPattern = this.tetromino[(this.tetromino.indexOf(this.activeTetromino) + 1) % this.tetromino.length];
            if(!this.collision(0, 0, nextPattern)){
                this.unDraw();
                this.activeTetromino = nextPattern;
                this.draw();
            }
        }

        lock() {
            for(let r = 0; r < this.activeTetromino.length; r++){
                for(let c = 0; c < this.activeTetromino.length; c++){
                    if(!this.activeTetromino[r][c]) continue;
                    if(this.y + r < 0) {
                        gameOver();
                        return;
                    }
                    board[this.y + r][this.x + c] = this.color;
                }
            }
            // 줄 제거 체크
            for(let r = 0; r < ROW; r++){
                let isFull = true;
                for(let c = 0; c < COL; c++){
                    if(board[r][c] == VACANT) isFull = false;
                }
                if(isFull){
                    for(let y = r; y > 1; y--){
                        for(let c = 0; c < COL; c++) board[y][c] = board[y-1][c];
                    }
                    for(let c = 0; c < COL; c++) board[0][c] = VACANT;
                    score += 100;
                }
            }
            drawBoard();
            scoreElement.innerHTML = score;
        }

        collision(x, y, piece) {
            for(let r = 0; r < piece.length; r++){
                for(let c = 0; c < piece.length; c++){
                    if(!piece[r][c]) continue;
                    let newX = this.x + c + x;
                    let newY = this.y + r + y;
                    if(newX < 0 || newX >= COL || newY >= ROW) return true;
                    if(newY < 0) continue;
                    if(board[newY][newX] != VACANT) return true;
                }
            }
            return false;
        }
    }

    // 블록 생성 시 I, T 등 모양별 회전 패턴 정의 보강
    function randomPiece() {
        let r = Math.floor(Math.random() * PIECES.length);
        let shape = PIECES[r][0];
        // 90도 회전 패턴 미리 생성 (단순화)
        let patterns = [shape];
        for(let i=0; i<3; i++) {
            let last = patterns[patterns.length-1];
            let next = last[0].map((_, idx) => last.map(row => row[idx]).reverse());
            patterns.push(next);
        }
        return new Piece(patterns, PIECES[r][1]);
    }

    function drawNext() {
        nctx.clearRect(0,0,80,80);
        for(let r = 0; r < nextP.activeTetromino.length; r++){
            for(let c = 0; c < nextP.activeTetromino.length; c++){
                if(nextP.activeTetromino[r][c]){
                    nctx.fillStyle = nextP.color;
                    nctx.fillRect(c*20 + 10, r*20 + 10, 20, 20);
                    nctx.strokeStyle = "#2c3e50";
                    nctx.strokeRect(c*20 + 10, r*20 + 10, 20, 20);
                }
            }
        }
    }

    function startGame() {
        initBoard();
        score = 0;
        scoreElement.innerHTML = score;
        document.getElementById('game-over').style.display = 'none';
        p = randomPiece();
        nextP = randomPiece();
        drawBoard();
        drawNext();
        gameRunning = true;
        dropStart = Date.now();
        update();
    }

    function update() {
        if(!gameRunning) return;
        let now = Date.now();
        let delta = now - dropStart;
        if(delta > 1000){
            p.moveDown();
            dropStart = Date.now();
        }
        requestAnimationFrame(update);
    }

    function gameOver() {
        gameRunning = false;
        document.getElementById('game-over').style.display = 'block';
    }

    document.addEventListener("keydown", (e) => {
        if(!gameRunning) return;
        if(e.keyCode == 37) p.moveLeft();
        else if(e.keyCode == 38) p.rotate();
        else if(e.keyCode == 39) p.moveRight();
        else if(e.keyCode == 40) p.moveDown();
        else if(e.keyCode == 32) { while(!p.collision(0,1,p.activeTetromino)) p.moveDown(); p.moveDown(); }
    });
</script>

</body>
</html>
