<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>후후의 테트리스</title>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #2c3e50;
            font-family: 'Malgun Gothic', sans-serif;
        }
        #tetris-game {
            display: flex;
            gap: 20px;
            border: 5px solid #34495e;
            padding: 20px;
            background-color: #ecf0f1;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            border-radius: 15px;
        }
        canvas {
            background-color: #1a1a1a;
            border: 2px solid #2c3e50;
        }
        #info {
            text-align: center;
            min-width: 160px;
        }
        h2 {
            margin: 0;
            background: #4CAF50;
            color: white;
            padding: 10px;
            border-radius: 8px;
            font-size: 1.2em;
        }
        .controls {
            text-align: left;
            font-size: 0.85em;
            background: #dfe6e9;
            padding: 10px;
            border-radius: 5px;
            margin: 15px 0;
            line-height: 1.6;
        }
        button {
            padding: 15px;
            cursor: pointer;
            font-size: 1.1em;
            font-weight: bold;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            width: 100%;
        }
        button:hover { background-color: #45a049; }
        #game-over { color: #d63031; font-weight: bold; display: none; margin-top: 10px; }
    </style>
</head>
<body>

<div id="tetris-game">
    <canvas id="board" width="200" height="400"></canvas>
    <div id="info">
        <h2>후후의 테트리스</h2>
        <p style="font-size: 1.2em; font-weight: bold;">점수: <span id="score">0</span></p>
        <p>NEXT</p>
        <canvas id="next" width="80" height="80"></canvas>
        <div class="controls">
            <strong>[조작키]</strong><br>
            ← → : 이동<br>
            ↑ : 회전<br>
            ↓ : 빨리 내리기<br>
            Space : 즉시 낙하
        </div>
        <button id="startBtn">게임 시작</button>
        <div id="game-over">GAME OVER</div>
    </div>
</div>

<script>
    const canvas = document.getElementById('board');
    const ctx = canvas.getContext('2d');
    const nextCanvas = document.getElementById('next');
    const nctx = nextCanvas.getContext('2d');
    const scoreElement = document.getElementById('score');
    const startBtn = document.getElementById('startBtn');

    const ROW = 20, COL = 10, SQ = 20;
    const VACANT = "#1a1a1a";

    const PIECES = [
        [[[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]], "#00cec9"], // I
        [[[0,1,0],[1,1,1],[0,0,0]], "#a29bfe"], // T
        [[[1,1],[1,1]], "#fdcb6e"], // O
        [[[0,1,1],[1,1,0],[0,0,0]], "#55efc4"], // S
        [[[1,1,0],[0,1,1],[0,0,0]], "#ff7675"], // Z
        [[[1,0,0],[1,1,1],[0,0,0]], "#fab1a0"], // L
        [[[0,0,1],[1,1,1],[0,0,0]], "#74b9ff"]  // J
    ];

    let board = [], score = 0, gameRunning = false, p, nextP, animationId;

    function initBoard() {
        for(let r = 0; r < ROW; r++) {
            board[r] = Array(COL).fill(VACANT);
        }
    }

    function drawSquare(x, y, color, context = ctx) {
        context.fillStyle = color;
        context.fillRect(x * SQ, y * SQ, SQ, SQ);
        context.strokeStyle = "#2c3e50";
        context.strokeRect(x * SQ, y * SQ, SQ, SQ);
    }

    function drawBoard() {
        for(let r = 0; r < ROW; r++) {
            for(let c = 0; c < COL; c++) {
                drawSquare(c, r, board[r][c]);
            }
        }
    }

    class Piece {
        constructor(tetromino, color) {
            this.tetromino = tetromino;
            this.color = color;
            this.activePattern = this.tetromino;
            this.x = 3;
            this.y = -1;
        }
        draw(color) {
            this.activePattern.forEach((row, r) => {
                row.forEach((value, c) => {
                    if (value) drawSquare(this.x + c, this.y + r, color);
                });
            });
        }
        moveDown() {
            if (!this.collision(0, 1, this.activePattern)) {
                this.y++;
                return true;
            } else {
                this.lock();
                return false;
            }
        }
        moveRight() { if (!this.collision(1, 0, this.activePattern)) this.x++; }
        moveLeft() { if (!this.collision(-1, 0, this.activePattern)) this.x--; }
        rotate() {
            let nextPattern = this.activePattern[0].map((_, i) => this.activePattern.map(row => row[i]).reverse());
            if (!this.collision(0, 0, nextPattern)) this.activePattern = nextPattern;
        }
        collision(x, y, piece) {
            for (let r = 0; r < piece.length; r++) {
                for (let c = 0; c < piece[r].length; c++) {
                    if (!piece[r][c]) continue;
                    let newX = this.x + c + x, newY = this.y + r + y;
                    if (newX < 0 || newX >= COL || newY >= ROW) return true;
                    if (newY < 0) continue;
                    if (board[newY][newX] !== VACANT) return true;
                }
            }
            return false;
        }
        lock() {
            for (let r = 0; r < this.activePattern.length; r++) {
                for (let c = 0; c < this.activePattern[r].length; c++) {
                    if (!this.activePattern[r][c]) continue;
                    if (this.y + r < 0) { gameRunning = false; document.getElementById('game-over').style.display = 'block'; return; }
                    board[this.y + r][this.x + c] = this.color;
                }
            }
            checkLines();
            p = nextP;
            nextP = randomPiece();
            drawNext();
        }
    }

    function checkLines() {
        for (let r = ROW - 1; r >= 0; r--) {
            if (board[r].every(cell => cell !== VACANT)) {
                board.splice(r, 1);
                board.unshift(Array(COL).fill(VACANT));
                score += 100;
                r++;
            }
        }
        scoreElement.innerHTML = score;
    }

    function randomPiece() {
        let r = Math.floor(Math.random() * PIECES.length);
        return new Piece(PIECES[r][0], PIECES[r][1]);
    }

    function drawNext() {
        nctx.clearRect(0, 0, 80, 80);
        nextP.activePattern.forEach((row, r) => {
            row.forEach((value, c) => {
                if (value) {
                    nctx.fillStyle = nextP.color;
                    nctx.fillRect(c * 20 + 10, r * 20 + 10, 20, 20);
                    nctx.strokeStyle = "#2c3e50";
                    nctx.strokeRect(c * 20 + 10, r * 20 + 10, 20, 20);
                }
            });
        });
    }

    let dropStart = Date.now();
    function animate() {
        if (!gameRunning) return;
        let now = Date.now();
        if (now - dropStart > 1000) {
            p.moveDown();
            dropStart = now;
        }
        drawBoard();
        p.draw(p.color);
        animationId = requestAnimationFrame(animate);
    }

    function startGame() {
        if(animationId) cancelAnimationFrame(animationId);
        initBoard();
        score = 0; scoreElement.innerHTML = score;
        document.getElementById('game-over').style.display = 'none';
        p = randomPiece();
        nextP = randomPiece();
        drawNext();
        gameRunning = true;
        animate();
    }

    startBtn.addEventListener('click', startGame);

    document.addEventListener("keydown", (e) => {
        if (!gameRunning) return;
        if (e.key === "ArrowLeft") p.moveLeft();
        else if (e.key === "ArrowUp") p.rotate();
        else if (e.key === "ArrowRight") p.moveRight();
        else if (e.key === "ArrowDown") p.moveDown();
        else if (e.key === " ") { while (p.moveDown()); }
        drawBoard(); p.draw(p.color);
    });
</script>
</body>
</html>
